#include "Arduino.h"
#include "Print.h"
#include "HardwareSerial.h"
#include <SPI.h>
#include "SH1106.h"
#include <avr/pgmspace.h>


// Display initialization

OLED_DISPLAY::OLED_DISPLAY(uint8_t chip_select, uint8_t data_command, uint8_t reset){
    _cs = chip_select;
    _dc = data_command;
    _res = reset;
    _page = 0;
    _column = 0;
    _buffer = (uint8_t*) (malloc(D_WIDTH*D_HEIGHT/8));
}

OLED_DISPLAY::~OLED_DISPLAY(){
  free(_buffer);
}


void OLED_DISPLAY::init(){
  
  SPI.begin();
  SPI.setBitOrder(MSBFIRST);

  pinMode(_cs, OUTPUT);
  pinMode(_dc, OUTPUT);
  pinMode(_res, OUTPUT);
  
  digitalWrite(_res, 0);
  delay(20);
  digitalWrite(_res, 1);

  command(DISPLAY_OFF); //Set display Off
  command(SET_CLOCK); //Set display clock divide ratio/oscillator frequency
  command(0xF0);
  command(MUX_RATIO); //Set multiplex ratio
  command(0x3F);
  command(DISPLAY_OFFSET); //Set display offset
  command(0x3F);
  command(START_LINE); //Set display start line
  command(0x8D); //Set charge pump
  command(0x14); //VCC generated by internal DC/DC circuit
  command(SEG_REMAP); //Set segment re-map 
  command(0xC8); //Set COM output scan direction
  command(SET_COM_HARD_CONF); //Set COM pins hardware configuration
  command(0x32);
  command(CONTRAST_CTRL_ENTER); //Set contrast control
  command(0x7F);
  command(SET_PRE_CHRG_PERIOD); //Set pre-changed period
  command(0x22);
  command(0xDB); //Set VCOMH Deselected level
  command(0x40);
  command(ENTIRE_DISPLAY_NORMAL); //Set entire display on/off
  command(NORMAL_DISPLAY); //Set normal display 
  
  //Set memory address mode
  command(ENTER_MEM_ADDR_MODE); 
  command(PAGE_ADDR_MODE);  
  
  command(DISPLAY_ON); //Turns the display ON
  clear(); //Clears the entire display
  command(PAGE_NUMBER | _page);
  
}

//Clearing the display
void OLED_DISPLAY::clear() {
  memset(_buffer, 0, D_WIDTH*D_HEIGHT/8);
  setCursor(0,0);
}


//Printing

void OLED_DISPLAY::print(int n){
  int n_copy = n * ((n >= 0)? 1 : -1);

  byte count  = (n==0)? 1: 0;
  while(n_copy != 0){
    n_copy/=10;
    count++;
  } 
  
  byte digits[count];
  n_copy = n * ((n >= 0)? 1 : -1);
  
  for(uint8_t i = count; i > 0; i--){
    digits[i - 1] = n_copy % 10;
    n_copy /= 10;
   
  }
  if(n < 0) print("-");
  for(uint8_t i = 0; i < count; i++ ){
    for(uint8_t j = 0; j < 6; j++){
      draw(pgm_read_byte(&(symbols[digits[i] + 16][j])));
    }
  }
}

void OLED_DISPLAY::print(const char* text){
  for(uint8_t i = 0; i < strlen(text); i++ ){
    for(uint8_t j = 0; j < 6; j++){
      draw(pgm_read_byte(&(symbols[text[i]-32][j])));
    }
  }
}

void OLED_DISPLAY::println(const char* text){
  print(text);
  println();    
}

void OLED_DISPLAY::println(){
  if(_page > (D_HEIGHT/8)-1){
    _page = 0;
  }else{
    _page++;
  }
  _column = 0;
}

void OLED_DISPLAY::setCursor(uint8_t page, uint8_t column){
  setPage(page);
  setColumn(column);
}

void OLED_DISPLAY::setPage(uint8_t page){  
  _page = page;
}

void OLED_DISPLAY::setColumn(uint8_t column){  
  _column = column;
}
//Drawing functions

void OLED_DISPLAY::drawCircle(uint8_t x, uint8_t y, uint8_t r){
 
}

void OLED_DISPLAY::drawFilledRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height){
  for(uint8_t i = x; i < x+width; i++){
    for(uint8_t j = y; j < y+height; j++){
      drawPixel(i,j);
    }
  }
}

void OLED_DISPLAY::drawRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height){
  drawLine(x, y, x + width, y);
  drawLine(x, y, x, y + height);
  drawLine(x, y + height, x + width, y + height);
  drawLine(x + width, y, x + width, y + height);
}

void OLED_DISPLAY::drawLine(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {   
  int16_t dx = abs(x1 - x0);
  int16_t dy = abs(y1 - y0);
  int16_t sx = (x0 < x1) ? 1 : -1;
  int16_t sy = (y0 < y1) ? 1 : -1;
  int16_t err = dx - dy;

  while (x0 != x1 || y0 != y1) {
    drawPixel(x0, y0);
    int16_t e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x0 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y0 += sy;
    }
  }
  drawPixel(x0, y0);
}

void OLED_DISPLAY::drawPixel(uint8_t x, uint8_t y){
  if(x < 0 || x > D_WIDTH - 1 || y < 0 || y > D_HEIGHT - 1) return;
  uint8_t page = y/8;
  uint8_t pixel = 1;
  pixel = pixel<<(y-(page*8));
  setCursor(page, x);
  draw(pixel);  
}

void OLED_DISPLAY::update(){
  for(uint8_t i = 0; i < D_HEIGHT/8; i++){ 
    command(PAGE_NUMBER | i); 
    command(0x10 | (0x0F & 2>>4));
    command(0x00 | (0x0F & 2));    
    for(uint8_t j = 0; j < D_WIDTH; j++){
      write_data(*(_buffer + j + (i * D_WIDTH)), 1);
    }    
  }

}

void OLED_DISPLAY::getBuffer(){
  for(uint16_t j = 0; j < D_WIDTH*D_HEIGHT/8; j++){  
      Serial.println(*(_buffer+j)) ;      
  }
  
}

void OLED_DISPLAY::draw(uint8_t data){
  *(_buffer + _column + (_page * D_WIDTH)) |= data;
  _column++;
  if(_column > D_WIDTH-1){
    _column = 0;
    _page++;
    if(_page > (D_HEIGHT/8)-1) _page = 0;
  } 
}


void OLED_DISPLAY::command(uint8_t data){
  write_data(data, 0);
}


//Low-level data transfer
void OLED_DISPLAY::write_data(uint8_t data, uint8_t dc){
  digitalWrite(_cs, 0);    
  digitalWrite(_dc, 0);
  if(dc) digitalWrite(_dc, 1);
  SPI.transfer(data);
  digitalWrite(_cs, 1);
}
